---
title: "Malware Reversing - Analysis 1: COM Objects"
date: 2019-08-01
tags: [malware]
categories: [reverse engineering]
---

I've been studying and practicing reverse engineering techniques for the better part of the past year and have found the book [Practical Malware Analysis](https://nostarch.com/malware) to be indispensible as it is very thorough and covers a variety of reversing skills. Additionally, one of the most beneficial aspects of this book is that it ships with dozens of realistic malware samples - all with varying behaviors and levels of sophistication. This is the first in a series of posts where I'll pick and choose different samples to do walkthroughs of the reversing process I took. I'll try to keep them relatively brief, focusing mainly on the unique properties of the malware or on specific techniques, avoiding an instruction-by-instruction analysis of the disassembly.

The malware samples analyzed may be downloaded [here](https://practicalmalwareanalysis.com/labs/).

This walkthrough will cover sample_07-02. After loading the malware sample in IDA, we'll just look for any interesting Strings or Imports that we can use for cross references to locations in the disassembly, away from all the compiler-generated code.

Viewing the Strings didn't immediately show anything interesting, just a few dll references; but allowing Unicode strings to be shown revealed a URL:

**pic of strings config**
**pic of strings listing**

Viewing the Imports showed something interesting as well. Imports such as `OleInitialize` and `CoCreateInstance` hint that the malware may take advantage of COM objects - more on this later.

**pic of imports**

Listing the Cross-References to the URL string found shows a single reference was made in `sub_401000`. Further investigating shows that the imports identified are also referenced exclusively in this subroutine. 

To get an idea of where this subroutine is in the bigger picture of the disassembly, I listed the Cross-References to the function and saw that it's only called in the `start` subroutine, which is the Entry Point of the program that everything else gets called from, including compiler-generated code.

**pic of xrefs**

Navigating to the address which calls this function shows typical initiation instructions beforehand as well as a call to `exit` afterwards.

**pic of __getmainargs assembly**

This makes it likely that `sub_401000` is either the main function or one of the core functions where malicious code was written, since the other subroutines reference imports and strings that seem to come from compiler-generated code or other dependencies. This serves as a good starting point for the analysis. The full listing of that subroutine is shown below: 

**pic of full main func**

The first thing that stands out in `sub_401000` are the calls to the imported `OleInitialize` and `CoCreateInstance` functions. These are two necessary functions used for interfacing with COM objects. COM is the Microsoft Component Object Model and is a standard which specifies how binary software components called COM objects can interact with one another. Since these components are binary, it does not matter about any of the implementation details before compilation (e.g. programming language, structure, etc.). The interactions of binary components may be acheived by calling methods of an interface that a COM object has implemented (https://docs.microsoft.com/en-us/windows/win32/com/the-component-object-model). In short, a program may run a function of another program, as defined by a COM interface. 

**pic of OleInitialize & CoCreateInstance**

Referencing Microsoft's API docs, [OleInitialize](https://docs.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-oleinitialize) initializes the COM library and must be called before other COM library functions can be used. [CoCreateInstance](https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) creates a local instance of a COM class object, specified by a globally unique identifier called the CLSID. This function provides a pointer to the interface which can be used to interact with the COM instance's functions.

After `OleInitialize` is called, we can see that five arguments are pushed to the stack before calling `CoCreateInstance`. 

The parameters required by `CoCreateInstance` are:

```c++
HRESULT CoCreateInstance(
  REFCLSID  rclsid,
  LPUNKNOWN pUnkOuter,
  DWORD     dwClsContext,
  REFIID    riid,
  LPVOID    *ppv
);
```

The most important of these are `rclsid`, `riid`, and `*ppv`. `rclsid` is the CLSID of the COM object to create; `riid` is the identifier of the interface that is required to interact with the COM object instance; and `*ppv` is where the pointer to that interface will be stored, if successful.

Following the reference to `riid` in IDA to where it is defined in the `rdata` segment gives us it's value:

**pic of rrid def**

Following the format for a GUID {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, this equates to an interface ID of `{D30C1661-CDAF-11D0-8A3E-00C04F0C90E26E}`.

A quick Google search shows that this IID corresponds to the <a href="https://docs.microsoft.com/en-us/dotnet/api/shdocvw.iwebbrowser2?view=dynamics-usd-3" class="keyword-link">IWebBrowser2</a> interface.

```c#
[System.Runtime.InteropServices.Guid("D30C1661-CDAF-11D0-8A3E-00C04FC9E26E")]
[System.Runtime.InteropServices.TypeIdentifier]
public interface IWebBrowser2 : SHDocVw.IWebBrowserApp
```

Viewing the value of `rclsid` in IDA shows:

**pic of clsid**

The value for the COM object's class ID is `{0002DF01-0000-0000-C000-000000000046}`.

To determine the program that this CLSID corresponds to, we can look in the registry at locations in either the `HKLM` or `HKCU` hives, under the path `\SOFTWARE\Classes\CLSID\`. Hundreds of CLSIDs are stored here; a subset is shown below:

**pic of CLSID listing**

Navigating to the CLSID we're looking for lists several keys.

**pic of our clisd**

Viewing the value for the `LocalServer32` key shows the exact file of the program that will be instantiated.

**pic of iexplore.exe path**

This is the executable for Internet Explorer, which implements the `IWebBrowser2` interface.

At this point in the disassembly, after `CoCreateInstance` returns, the malware has access to the COM functionality of the `IWebBrowser2` interface as implemented by Internet Explorer.

The malware continues on to call `SysAllocString` to allocate space for a string referenced by `psz` (naming convention by IDA indicates a pointer to a NULL terminated string). Viewing the declaration of this string shows that it is a URL `http://www.malwareanalysisbook.com/ad.html`. 

**pic of IDA, string being allocated**

The next call is to an address referenced by `[edx + 2Ch]` at [1]. If we trace the instructions back up, we can see at [2] that `eax` is set to the variable `ppv`, which holds the pointer to the `IWebBrowser2` interface. The call isn't being made directly to the start address of the interface however, but to a an offset of `2Ch` within the interface struct. This struct contains function pointers at each offset and the current instruction is calling one of those functions.

To determine which function pointer is located at an offset of `2Ch` within the interface, we can utilize a feature of IDA and it's included definitions of standard structures. 

To do this, first we'll open the Structures view and add a new one by pressing the INSERT key. Then click `Add Standard Structure` and search for the interface `IWebBrowser2`. This isn't the struct that we'd like to add however. Looking closely at the Declaration shows that it is simply defined with a pointer to the struct `IWebBrowser2Vtbl`; that's the structure that we want to add instead since it's declaration contains all the actual struct members.

**pic of choose a structure window**

Adding that struct gives us all of the function pointers as members and the offsets of each. We can now see that the function pointer being called at the offset of `2Ch` is `Navigate`. 

**pic of struct members**

Going back to the disassembly, the offset can now be automatically replaced with the method name by right-clicking `2Ch` and selecting `[edx+IWebBrowser2Vtbl.Navigate]`.

**pic of context menu**

The `Navigate` method is used to navigate to a resource, either a local file or website, depending on the identifier passed in to it as an argument. Considering we found a URL string being copied earlier, it's safe to assume it's the latter. And actually at this point, a reasonably clear picture has been painted of what the malware is doing in general, but we'll verify in the disassembly anyways. The parameters that this method takes are listed here:

```c++
HRESULT Navigate(
    BSTR url,
    VARIANT *Flags,
    VARIANT *TargetFrameName,
    VARIANT *PostData,
    VARIANT *Headers
);
```

Starting at [1], we can see the five arguments being pushed to the stack for the call to `IWebBrowser2.Navigate ` in the following listing. 

**pic of args being pushed to stack**

The pointer to the URL string from earlier is stored in `eax` at [2] as the return value of `SysAllocString`, and is subsequently copied to `esi` and then pushed to the stack as the **2nd argument - figure out why!! probably need to analyze with debugger**.

This shows that when `Navigate` is called, Internet Explorer will open up and display the web page at `http://www.malwareanalysisbook.com/ad.html`, which appears to be an advertisement. Following this, the malware just frees up some resources and exits. 

This piece of malware is very simple but shows how COM objects may be initialized and used maliciously.

Network indicators: 
Host-based indicators: 
Preventative measures that could be taken against this:
	-block requests to web domain
	-prevent use of COM objects except by signed software

