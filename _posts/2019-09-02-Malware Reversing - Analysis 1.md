---
title: "Malware Reversing - Analysis 1: COM Objects"
date: 2019-09-02
tags: [malware]
categories: [reverse engineering]
author_profile: false
---

I've been researching and practicing reverse engineering techniques for the better part of the past year and have found the book [Practical Malware Analysis](https://nostarch.com/malware) to be a very useful resource as it is very thorough and covers a variety of reversing skills. Additionally, one of the most beneficial aspects of this book is that it ships with dozens of realistic malware samples - all with varying behaviors and levels of sophistication. This is the first in a series of posts where I'll pick and choose different samples to do walkthroughs of the reversing process I took. I'll try to keep them relatively brief, focusing mainly on the unique properties of the malware or on specific techniques, avoiding an instruction-by-instruction analysis of the disassembly.

The malware samples analyzed may be downloaded [here](https://practicalmalwareanalysis.com/labs/).

This walkthrough will cover sample_07-02. After loading the malware sample in IDA, we'll start by looking for any interesting Strings or Imports that we can use for cross references to locations in the disassembly that are likely the malware's custom code, away from all the compiler-generated code.

Viewing the Strings didn't immediately show anything interesting, just a few dll references; but allowing Unicode strings to be shown revealed a URL:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/unicode_option_rgb.png" alt="Option to show unicode strings in listing" class="left-align" style="width:calc(440px * .66667)">

After selecting `Unicode C-style (16 bits)` above, the apparent URL below became visible:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/unicode_strings_rgb.png" alt="Strings listing" class="left-align shadow" style="width:calc(906px * .66667)">


Viewing the Imports showed something interesting as well. Imports such as `OleInitialize` and `CoCreateInstance` hint that the malware may take advantage of COM objects - more on this later:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/imports_rgb.png" alt="Imports listing" class="left-align shadow" style="width:calc(769px * .66667)">

Listing the Cross-References to the URL string found shows a single reference was made in `sub_401000`. Further investigating shows that the imports identified are also referenced exclusively in this subroutine. 

To get an idea of where this subroutine is in the bigger picture of the disassembly, I listed the Cross-References to the function and saw that it's only called in the `start` subroutine, which is the Entry Point of the program that everything else gets called from, including compiler-generated code:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/xrefs_rgb.png" alt="cross references" class="left-align" style="width:calc(1030px * .66667)">

Navigating to the address which calls this function shows typical initiation instructions beforehand as well as a call to `exit` afterwards:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/sub_401000_calling_func_rgb.png" alt="Disasembly of calling function" class="left-align shadow" style="width:calc(1472px * .66667)">

This makes it likely that `sub_401000` is either the main function or one of the core functions where malicious code is written, since the other subroutines reference imports and strings that seem to come from compiler-generated code or other dependencies. This serves as a good starting point for the analysis. The full listing of that subroutine is shown below: 

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/main_rgb.png" alt="Disasembly of main function" class="left-align shadow" style="width:calc(1460px * .66667)">

The first thing that stands out in `sub_401000` are the calls to the imported `OleInitialize` and `CoCreateInstance` functions. These are two necessary functions used for interfacing with COM objects. COM is the Microsoft Component Object Model and is a standard which specifies how binary software components, called COM objects, can interact with one another.

Since these components are binary, it does not matter about any of the implementation details before compilation (e.g. programming language, structure, etc.). The interactions of binary components may be acheived by calling methods of an interface that a [COM object](https://docs.microsoft.com/en-us/windows/win32/com/the-component-object-model) has implemented. In short, a program may run a function of another program, as defined by a COM interface. 

Referencing Microsoft's API docs, [OleInitialize](https://docs.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-oleinitialize) initializes the COM library and must be called before other COM library functions can be used. [CoCreateInstance](https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) creates a local instance of a COM class object, specified by a globally unique identifier called the CLSID. This function provides a pointer to the interface which can be used to interact with the COM instance's functions.

After `OleInitialize` is called, we can see that five arguments are pushed to the stack before calling `CoCreateInstance`. 

The parameters required by `CoCreateInstance` are:

```c++
HRESULT CoCreateInstance(
  REFCLSID  rclsid,
  LPUNKNOWN pUnkOuter,
  DWORD     dwClsContext,
  REFIID    riid,
  LPVOID    *ppv
);
```

The most important of these are `rclsid`, `riid`, and `*ppv`. `rclsid` is the CLSID of the COM object to create; `riid` is the identifier of the interface that is required to interact with the COM object instance; and `*ppv` is where the pointer to that interface will be stored, if successful.

Following the reference to `riid` in IDA to where it is defined in the `rdata` segment gives us it's value:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/riid.png" alt="RIID disassembly in IDA" class="left-align shadow" style="width:calc(1500px * .66667)">

Following the format for a GUID {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, this equates to an interface ID of `{D30C1661-CDAF-11D0-8A3E-00C04F0C90E26E}`.

A quick Google search shows that this IID corresponds to the <a href="https://docs.microsoft.com/en-us/dotnet/api/shdocvw.iwebbrowser2?view=dynamics-usd-3" class="keyword-link">IWebBrowser2</a> interface.

```c#
[System.Runtime.InteropServices.Guid("D30C1661-CDAF-11D0-8A3E-00C04FC9E26E")]
[System.Runtime.InteropServices.TypeIdentifier]
public interface IWebBrowser2 : SHDocVw.IWebBrowserApp
```

Viewing the value of `rclsid` in IDA shows:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/rclsid_rgb.png" alt="RCLSID disassembly in IDA" class="left-align shadow" style="width:calc(1502px * .66667)">

The value for the COM object's class ID is `{0002DF01-0000-0000-C000-000000000046}`.

To determine the program that this CLSID corresponds to, we can look in the registry at locations in either the `HKLM` or `HKCU` hives, under the path `\SOFTWARE\Classes\CLSID\`. Hundreds of CLSIDs are stored here; a subset is shown below:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/clsid_listing.png" alt="Listing of CLSIDs in the registry" class="left-align shadow" style="width:calc(593px * .66667)">

Navigating to the CLSID we're looking for lists several keys.

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/ie_clsid.png" alt="CLSID of Internet Explorer" class="left-align shadow" style="width:calc(443px * .66667)">

Viewing the value for the `LocalServer32` key shows the exact file of the program that will be instantiated.

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/ie_path.png" alt="Path of Internet Explorer shown as value in CLSID" class="left-align shadow" style="width:calc(780px * .66667)">


This is the executable for Internet Explorer, which implements the `IWebBrowser2` interface.

At this point in the disassembly, after `CoCreateInstance` returns, the malware has access to the COM functionality of the `IWebBrowser2` interface as implemented by Internet Explorer.

The malware continues on to call `SysAllocString` to allocate space for a string referenced by `psz` (naming convention by IDA indicates a pointer to a NULL terminated string). Viewing the declaration of this string shows that it is a URL `http://www.malwareanalysisbook.com/ad.html`. 

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/sysallocstring.png" alt="SysAllocString being called in disassembly" class="left-align shadow" style="width:calc(1492px * .66667)">

The next call made is to an address referenced by `[edx + 2Ch]`, shown below at 00401074:

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/call_edx2ch.png" alt="call being made directly to the address [edx + 2Ch]" class="left-align shadow" style="width:calc(1492px * .66667)">

If we trace the instructions back up, we can see that `eax` is set to the variable `ppv` which holds the pointer to the `IWebBrowser2` interface, before moving its value to `edx`. The call isn't being made directly to the start address of the interface however, but to a an offset of `2Ch` within the interface struct. This struct contains function pointers at each offset and the current instruction is calling one of those functions.

To determine which function pointer is located at an offset of `2Ch` within the interface, we can utilize the definitions of standard structures that IDA includes. 

To do this, first we'll open the Structures view and add a new structure by pressing the INSERT key. Then click `Add Standard Structure` and search for the interface `IWebBrowser2`. This isn't the struct that we'd like to add however. Looking closely at the Declaration shows that it is simply defined with a pointer to the struct `IWebBrowser2Vtbl`; that's the structure that we want to add instead since its declaration contains all the actual struct members.

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/choose_structure.png" alt="Choose a Structure window" class="left-align" style="width:calc(1217px * .66667)">

Adding that struct gives us all of the function pointers as members and the offsets of each. We can now see that the function pointer being called at the offset of `2Ch` is `Navigate`. 

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/struct_members.png" alt="Structure Members" class="left-align shadow" style="width:calc(1017px * .66667)">

Going back to the disassembly, the offset can now be automatically replaced with the method name by right-clicking `2Ch` and selecting `[edx+IWebBrowser2Vtbl.Navigate]`.

<img src="{{ site.url }}{{ site.baseurl }}/images/RE1/context_menu.png" alt="Context menu auto-replace struct name" class="left-align shadow" style="width:calc(870px * .66667); border-radius:0">

The `Navigate` method is used to navigate to a resource, either a local file or website, depending on the identifier passed to it as an argument. Considering we found a URL string being copied earlier, it's safe to assume it's the latter, but we'll quickly verify in the disassembly anyways. The parameters that this method takes are listed here:

```c++
HRESULT Navigate(
    BSTR url,
    VARIANT *Flags,
    VARIANT *TargetFrameName,
    VARIANT *PostData,
    VARIANT *Headers
);
```

Prior to the call to `IWebBrowser2.Navigate`, we can see the arguments being pushed to the stack. The pointer to the URL string from earlier is stored in `eax` at 00401050 as the return value of `SysAllocString`, and is subsequently copied to `esi` and then pushed to the stack. When `Navigate` is called, Internet Explorer will open up and display the web page at `http://www.malwareanalysisbook.com/ad.html`, which appears to be an advertisement. Following this, the malware just frees up some resources and exits. 

This piece of malware is fairly simple but shows how COM objects may be initialized and used maliciously.

